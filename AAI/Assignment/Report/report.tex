\documentclass{article}
\title{Game AAI Assignment}
\author{Tim Hintzbergen and Sjoerd Dekker}
\date{March 2018}
% include packages
\usepackage{graphicx}
\usepackage{caption}
\usepackage{mathabx}
\DeclareCaptionFormat{cancaption}{#1#2#3\par} % Normal format actually
\DeclareCaptionLabelFormat{cancaptionlabel}{#1}
\captionsetup[figure][number]{format=cancaption,labelformat=cancaptionlabel}
\graphicspath { {images/} }
\begin{document}
   \maketitle
   \newpage
   
   \tableofcontents{}
   %------------------------------------------------------------------------------------------------------------------------------------------------------- Introduction
   \newpage
   \section {Introduction}
   Something about animals and stuff
   \newpage
   
   %------------------------------------------------------------------------------------------------------------------------------------------------------- Steering behaviours
   \section{Steering behaviours}
   The following steering behaviours are implemented. 
   \subsection{Simple steering behaviours}
   \subsubsection {Arrive}
   The entity will try to go in a straight line to a specified goal. When the entity gets close to the goal the entity will slow down. This behaviour will stop when the entity is on or very near its goal and the current speed of the entity is very low. 
   \subsubsection {Flee}
   The entity will try to run away from entities that are the same type as specified. The closer another entity is the more the current entity will try to run away from the other entity. This algoritm will only search in an area, if there are no entities in the area the entity will not try to run away.
   \subsubsection {Seek}
   This algoritm has the opposite behaviour from flee. However in this algoritm there is only one entity set to seek. If the specified entity to seek is to far away this behaviour will stop working.
   \subsubsection {Wander}
  This algoritm will create a circle in front of the entity, on this circle there is a dot. This dot will move randomly along the circle. The entity will go towards the dot, the farther away the dot is from the entity the more force is applied. 
  \subsection{Advanced steering behaviours}
  \subsubsection {Flocking}
  First all entities of the same type are searched in a radius around the current entity, exluding itself. The current entity will do the following three behaviours: 
  \begin{itemize}
  \item Alignment: the entity will calculate the average direction off all the entities in the area. After this the entity will try to have the same direction as the average.
  \item Cohesion: the entity will try to go towards the average location of all the entities in the area.
  \item Separation: the entity  will try to go away from all the entities in the area. 
  \end{itemize}
  \subsubsection {Obstacle avoidance}
  
  \subsubsection {Path following}
   This algoritm will create a path to a specified location using the A* algoritm. After the A* algoritm has found a path then this path will be smoothed. When the smoothing is done the agent will follow the path. This is done using the arrive algoritm. 
   \newpage
   
   %------------------------------------------------------------------------------------------------------------------------------------------------------- Path finding
   \section {Path finding}
   \subsection {Grid}
   \subsection {A*}
   \subsection {Time slicing}
   
 
   \newpage   
   %------------------------------------------------------------------------------------------------------------------------------------------------------- States
   \section {States}
   The simulation uses states to determine what the entities should be doing. Each entity keeps track of its own state and the previous state. In figure ~\ref{fig:stateClassDiagram} the relavent classes properties and methods are shown. 
   \begin{figure}[h!]
   \includegraphics[width=\textwidth]{stateuml.png}
   \caption{State class diagram}
   \label{fig:stateClassDiagram}
   \end{figure}
   When the simulation is started the Initialize method in StateMachine is called, this will preload all the scripts.
   \subsection {Scripting}
   States are scripted in Lua. Each state for every entity type has its own script file. Each file has to have atleast three functions: 
   \begin{itemize}
   \item enter(entity, world). This function is called when the entity switches to this state. In this function the necessary steeringbehaviours are added to the entity.
   \item execute(entity, world). This function is called on every tick that the state is active. This function should update relevant values for the entity. This function has to return the new state as a string, if the state should not change then it has to return the name of the current state.
   \item exit(entity, world). This function is called when the entity leaves this state. In here, if necessary, the steeringbehaviours should be removed.
   \end{itemize}
   The first parameter is the current entity, the second parameter is the gameworld instance. C\# namespaces can be imported in the scripts. This can be done by adding an import statement to the top of the script file, eg: import('System').
   
   \newpage
   %------------------------------------------------------------------------------------------------------------------------------------------------------- Partitioning
   \section {Partitioning}
   The world is split into multiple cells. These cells are layed out in a grid pattern. The size of the cells can be set in the settings.ini file. An entity is always in one of these cells. When an entity moves the corrresponding cell in which the entity is located is recalculated. Searching for entities in an area works in the following manner (the area to search in is always round):
   \begin{enumerate}
   \item Calculate which cells contain some of the area of the search circle.
   \item Get all the entities from the cells in step 1.
   \item for every entity calculate the distance from the center of the circle, if this is more than the radius of the circle then remove this entity.
   \end{enumerate}
   The cells can be rendered to the screen by clicking the "spatialPartitioning Grid" option under the "view" button. 
\end{document}