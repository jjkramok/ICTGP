\documentclass{article}
\title{Game AAI Assignment}
\author{Tim Hintzbergen and Sjoerd Dekker}
\date{March 2018}
% include packages
\usepackage{graphicx}
\usepackage{caption}
\usepackage{mathabx}
\DeclareCaptionFormat{cancaption}{#1#2#3\par} % Normal format actually
\DeclareCaptionLabelFormat{cancaptionlabel}{#1}
\captionsetup[figure][number]{format=cancaption,labelformat=cancaptionlabel}
\graphicspath { {images/} }
\begin{document}
   \maketitle
   \newpage
   
   \tableofcontents{}
   %------------------------------------------------------------------------------------------------------------------------------------------------------- Introduction
   \newpage
   \section {Introduction}
   Something about animals and stuff
   \newpage
   
   %------------------------------------------------------------------------------------------------------------------------------------------------------- Steering behaviours
   \section{Steering behaviours}
   The following steering behaviours are implemented. 
   \subsection{Simple steering behaviours}
   \subsubsection {Arrive}
   The entity will try to go in a straight line to a specified goal. When the entity gets close to the goal the entity will slow down. This behaviour will stop when the entity is on or very near its goal and the current speed of the entity is very low. 
   \subsubsection {Flee}
   The entity will try to run away from entities that are the same type as specified. The closer another entity is the more the current entity will try to run away from the other entity. This algoritm will only search in an area, if there are no entities in the area the entity will not try to run away.
   \subsubsection {Seek}
   This algoritm has the opposite behaviour from flee. However in this algoritm there is only one entity set to seek. If the specified entity to seek is to far away this behaviour will stop working.
   \subsubsection {Wander}
  This algoritm will create a circle in front of the entity, on this circle there is a dot. This dot will move randomly along the circle. The entity will go towards the dot, the farther away the dot is from the entity the more force is applied. 
  \subsection{Advanced steering behaviours}
  \subsubsection {Flocking}
  First all entities of the same type are searched in a radius around the current entity, exluding itself. The current entity will do the following three behaviours: 
  \begin{itemize}
  \item Alignment: the entity will calculate the average direction off all the entities in the area. After this the entity will try to have the same direction as the average.
  \item Cohesion: the entity will try to go towards the average location of all the entities in the area.
  \item Separation: the entity  will try to go away from all the entities in the area. 
  \end{itemize}
  \subsubsection {Obstacle avoidance}
  
  \subsubsection {Path following}
   This algoritm will create a path to a specified location using the A* algoritm. After the A* algoritm has found a path then this path will be smoothed. When the smoothing is done the agent will follow the path. This is done using the arrive algoritm. 
   \newpage
   
   %------------------------------------------------------------------------------------------------------------------------------------------------------- Path finding
   \section {Path finding}
   \subsection {Grid}
   \subsection {A*}
   \subsection {Time slicing}
   
 
   \newpage   
   %------------------------------------------------------------------------------------------------------------------------------------------------------- States
   \section {States}
   The simulation uses states to determine what the entities should be doing. Each entity keeps track of its own state and the previous state. In figure~\ref{fig:stateClassDiagram} the relavent classes properties and methods are shown. 
   \begin{figure}[h!]
   \includegraphics[width=\textwidth]{stateuml.png}
   \caption{State class diagram}
   \label{fig:stateClassDiagram}
   \end{figure}
   When the simulation is started the Initialize method in StateMachine is called, this will preload all the scripts. All scripts are located in the scripts folder. The scripts are seperated into folders, each folder is linked, based on the name, to an entity type.
   The default states for every entity type are set in the settings.ini file.
   \subsection {Scripting}
   States are scripted in Lua. Each state for every entity type has its own script file. Each file has to have atleast three functions: 
   \begin{itemize}
   \item enter(entity, world). This function is called when the entity switches to this state. In this function the necessary steeringbehaviours are added to the entity.
   \item execute(entity, world). This function is called on every tick that the state is active. This function should update relevant values for the entity. This function has to return the new state as a string, if the state should not change then it has to return the name of the current state.
   \item exit(entity, world). This function is called when the entity leaves this state. In here, if necessary, the steeringbehaviours should be removed.
   \end{itemize}
   The first parameter is the current entity, the second parameter is the gameworld instance. C\# namespaces can be imported in the scripts. This can be done by adding an import statement to the top of the script file, eg: import('System').
   
   When the simulation is running the BaseEntity Update method will call the StateMachine Execute method. The stateMachine execute method will call the necessary methods in the scripts using the RunFunctionScript method. If the state changes the exit function of the previous state and the enter function of the new state are executed.
   
   \newpage
   %------------------------------------------------------------------------------------------------------------------------------------------------------- Partitioning
   \section {Partitioning}
   The world is split into multiple cells. These cells are layed out in a grid pattern. The size of the cells can be set in the settings.ini file. An entity is always in one of these cells. When an entity moves the corrresponding cell in which the entity is located is recalculated. Searching for entities in an area works in the following manner (the area to search in is always round):
   \begin{enumerate}
   \item Calculate which cells contain some of the area of the search circle.
   \item Get all the entities from the cells in step 1.
   \item for every entity calculate the distance from the center of the circle, if this is more than the radius of the circle then remove this entity.
   \end{enumerate}
   The cells can be rendered to the screen by clicking the "spatialPartitioning Grid" option under the "view" button. 
   
    \newpage
   %------------------------------------------------------------------------------------------------------------------------------------------------------- Fuzzy logic
   \section {Fuzzy logic}
   Fuzzy logic works in three steps. The values that go in and go out of the algoritms are crisp values. All the graphs have a left and right shoulder and zero or more trapezoidal shaped sets. All the lines in the graph are either diagonal or horizontal.
   \subsection{Fuzzyfication}
   In this step the graphs are loaded from a text file (fuzzyrules/graphs.txt). For every graph these values need to be set: 
   \begin{itemize}
   \item MIN: the minimal value in the graph.
   \item MAX: the maximum value in the graph.
   \item SECTIONS: the names of the sets in the graph.
   \item SPACING: the values where the sets should stop and begin (there should be \( (section count) \times 2 - 2\) values in spacing).
   \end{itemize}
   \subsection{Fuzzy rules}
   
   \subsection{Defuzzification}
   In the project there are three methods for defuzzification. The method can be set in the Settings.ini file.
   
   \subsubsection {Mean of maximum}  
   This method will calculate the average value for the set with the highest degree of membership. In figure~\ref{fig:MOM} the result would be \(\frac{73}{100}=86.5\). 
   \begin{figure}[h!]
   \begin{center}
   \includegraphics[width=7cm]{MOM.png}
   \end{center}
   \caption{Mean of maximum example}
   \label{fig:MOM}
   \end{figure}
   \subsubsection {Centroid}  
   This method will calculate the weighted average of the degree of membership (DOM) for an amount of locations. The amount of locations can be set in the Settings.ini file. The following calculations are executed at every location:
   \[ \alpha += DOM \times location \]
   \[ \beta += DOM \]
   Both \(\alpha\) and \(\beta\) have a starting value of zero.
   The result is calculated using the following formula:
   \[ result = \frac{\alpha}{\beta} \]
   
   \subsubsection {Average of maxima}  
   This method will calculate the average of the degree of membership for every set. An example is shown in figure~\ref{fig:maxAv}.
   \begin{figure}[h!]
   \begin{center}
   \includegraphics[width=7cm]{maxAv.png}
   \end{center}
   \[ result = \frac{0.36 \times ((0 + 26) / 2) + 0.23 \times ((17 + 77) / 2) + 0.71 \times ((73 + 100) / 2)}{0.36 + 0.23 + 0.71} = \frac{76.9}{1.3} = {59.16}\]
   \caption{Average of maxima example}
   \label{fig:maxAv}
   \end{figure}
   
\end{document}

































